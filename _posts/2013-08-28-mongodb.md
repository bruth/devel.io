---
published: false
layout: post
title: MongoDB
summary: Notes on learning MongoDB from a relational database perspective.
---

### Schemas

- The [schema](http://en.wikipedia.org/wiki/Database_schema) vs. schemaless argument boils down to whether the database system requires a _predefined_ schema
- Data that _is_ schemaless could be a nightware to work with
- If not explicitly defined, most data have a natural schema
- Shoving any and all data into a single target (e.g. a MongoDB collection) is roughly equivalent to writing all that data to a text file. It will have to be parsed for it to be useable.

#### Flexibility

- Every document in a single collection _could_ be different
- Collections are _dumb_ since each document holds the information about it's own _schema_
	- This also comes with a lot of redundancy in a collection is _regular_
- Databases and collections are created _on-the-fly_ which makes it simple for automatic loading of random bits of data from different sources
	- Which them could be consolidated later

### Terminology

- **database** - Exist within a Mongo instance.
- **collection** - Exist within a database and are conceptually equivalent to tables in a relational database.
- **document** - Exist within a collection and are conceptually equivalent to rows in a relational database.
- **field** - Defined on a document and are conceptually equivalent to columns in a relational database.
- **index** - Defined on collections and are conceptually equivalent to indexes in a relational database.
- **cursor** - Primary interface to the data. This is the same as with relational database drivers.

### Use Cases

- Storage for _longer_-term cache when something like [memcached](memcached.org) is too volatile or data structures are needed
- Intermediate or staging storage for [ETL](http://en.wikipedia.org/wiki/Extract,_transform,_load)

### Details

- BSON is the internal storage format, JSON is the API layer format
- `db.system.indexes` is created (implicitly) once per database to store information about indexes
- Every document has a `_id` field generated if one is not supplied
- The `_id` field is indexed per collection

### Selectors

- Similiar to the `WHERE` clause in SQL
- Arrays are traversed implicitly
- Selectors are specified as JavaScript objects themselves, e.g. `{age: {$gt: 10}}`
- `{}` selector matches all documents
- Few common ones
	- exact match does not use an operator, e.g. `{middle_name: 'James'}`
    - `$ne` - not equal
	- `$exists` - presence/absence of a field, e.g. `{middle_name: {$exists: true}}`
    - `$lt`, `$lte`, `$gt`, `$gte` - numerical operators
    - `$or` - groups conditions for a logical OR rather than AND, e.g. `{$or: [{$color: 'blue'}, {$color: 'red'}]}`
- Most flexible one is `$where` in which a function can be supplied to filter results

### Methods

#### Find

- Signature: `db.collection.find(<selector>, <projection>)`
- The `projection` decides which fields to return by the cursor
	- `db.users.find({contact: true}, {name: 1, email: 1})` returns all names and email addresses for those who want to be contacted
    - The `_id` is always returned unless the projection disables it explicitly, i.e. `{_id: 0}`

#### Sort

- Signature: `cursor.sort(<ordering>)`
- The `ordering` document contains field names with `1` for ascending or `-1` for descending, e.g. `db.users.find().sort({dob: -1})` for the oldest users first

#### Limit

- Signature: `cursor.limit(<int>)`
- Limit the documents being fetched

#### Skip

- Signature: `cursor.skip(<int>)`
- Skip the first N documents

#### Count

- Signature: `cursor.count()` or directly on the collection: `db.collection.count()`

#### Update

- Signature: `db.collection.update(<selector>, <document>, <upsert>, <multiple>)`
- Default behavior is to _replace_ matched documents
- Use the `$set` modifier to update individual attributes, `{$set: {color: 'Blue'}}` rather than `{color: 'Blue'}`
- Other `update` modifiers
	- `$inc` - adds the value to a number (positive or negative)
    - `$push` - appends a new value/document to an array
- Set `upsert` to true to create the document being updated if it doesn't exist
	- Useful for counters, `db.foo.update({name: 'counter x'}, {$inc: {count: 1}}, true)` which find or create the document `{name: 'counter x'}` and increment `count` by one. If the document is new, the value will be incremented from 0
    - Creating lists on the fly, `db.foo.update({name: 'colors'}, {$push, {values: 'blue'}}, true)` will find or create the document `{name: 'colors'}` and append `'blue'` to `values`. If the document is new, `values` will be initialized as an empty array prior to the push.
- By defaults, `update(...)` affect at most one document (the first one found) unless the `multiple` argument is `true`

### References

- [The Little MongoDB Book](http://openmymind.net/2011/3/28/The-Little-MongoDB-Book/) by Karl Seguin
- [MongoDB Manual](http://docs.mongodb.org/manual/) (of course)
- [MongoDB Reference Cards](http://www.mongodb.com/reference)
- [MongoDB Presentations](http://www.mongodb.com/presentations)